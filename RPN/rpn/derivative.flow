import simplifier;

export {
	ar2diff(ar:ArExp, var: string) -> ArExp;
}

ar2diff(ar:ArExp, var: string) -> ArExp {
	simplifyTree(diffArImpl(ar, var));
}

diffArImpl(ar:ArExp, var: string) -> ArExp {
	switch (ar) {
		ArPow(l, power): 
			if(containsVariable(l) && containsVariable(power))// (x^x)'
				diffArImpl(ArPow(ArDouble(E_CONST), ArMult(power, l)), var)
			else if(containsVariable(l) && !containsVariable(power)) // (x^n)'
				ArMult(diffArImpl(l, var), ArMult(power, ArPow(l,ArMin(power, ArDouble(1.0)))))
			else if(!containsVariable(l) && containsVariable(power)) // (n^x)'
				ArMult(diffArImpl(power, var), ArMult(ar, ArLn(l)))
			else ArDouble(0.0);	//const'
		ArDiv(up, down): 
			if(containsVariable(up) || containsVariable(down))//(f(x)/g(x))'
				ArDiv(ArMin(ArMult(diffArImpl(up, var), down), ArMult(up, diffArImpl(down, var))), ArMult(down,down))
			else ArDouble(0.0);//const
		ArMin(l, r): 
			ArMin(diffArImpl(l, var), diffArImpl(r, var));
		ArSum(l, r): 
			ArSum(diffArImpl(l, var), diffArImpl(r, var));
		ArMult(l, r): 
			ArSum(ArMult(diffArImpl(l, var), r), ArMult(diffArImpl(r, var), l));
		ArLn(val):
			ArMult(ArDiv(ArDouble(1.0), val), diffArImpl(val, var));
		ArDouble(val): 
			ArDouble(0.0);
		ArVar(var0):
			if(var0 == var) ArDouble(1.0) else ArDouble(0.0);	
	}
}

containsVariable(ar:ArExp) -> bool {
	switch(ar) {
		ArVar(var):
			true;
		ArDouble(val):
			false;
		default:{
			arr = extractArgs(ar);
			containsVariable(arr[0]) || containsVariable(arr[1]);
		}	
	}

			
}