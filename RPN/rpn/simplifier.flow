import syntax_tree;

export {
	simplifyTree(ar:ArExp) -> Maybe<ArExp>;
}

simplifyTree(ar:ArExp) -> Maybe<ArExp> {
	//Find simple expression like a^1, a+0, a*0, a-0 etc
	x = removeTrivialExp(ar, None(), 0);

	switch (x) {
		None():
			None();
		Some(val)://Fold x+x+x+x+x+...+x to nx and x*x*x*x*...*x = x^n etc
			foldEqualOperands(val, None(), 0);	
	}
}

foldEqualOperands(ar:ArExp, old: Maybe<ArExp>, iteration: int) -> Maybe<ArExp> {
	if(isNone(old) && iteration > 0)
		None()
	else {
		Some(ar);//STUB
	}	
}

removeTrivialExp(ar:ArExp, old: Maybe<ArExp>, iteration: int) -> Maybe<ArExp> {
	if(isNone(old) && iteration > 0)
		None()
	else {
		it0 = execSimplifier(Some(ar), \op, ar0 -> {
			if(op != "^")
				Some(ar0)
			else
			{
				p = cast(ar0 : ArExp -> ArPow);
				switch(detectOperands(p.l,p.pow)) { //We don't know about variables, so we cant find out anything in many situations
					IntInt(l0,r0):
						if(r0 == 0)//x^0
							Some(ArInt(1))
						else if(r0 == 1)//x^1
							Some(ArInt(l0))
						else {
							if(l0 == 1)//1^x
								Some(ArInt(1))
							else if(l0 == 0)//0^x, there we can set it, because of x != 0, it we can find out from the conditions above
								Some(ArInt(0))
							else
								Some(ar0);	
						}	
					VarInt(l0,r0):
						if(r0 == 0) //x^0
							Some(ArInt(1))
						else if(r0 == 1) //x^1
							Some(ArVar(l0))
						else
							Some(ar0);
					ExpInt(l0,r0):
						if(r0 == 0) //x^0
							Some(ArInt(1))
						else if(r0 == 1) //x^1
							Some(l0)
						else
							Some(ar0);		
					IntVar(l0,r0):
						if(l0 == 1) //1^x, we can't add condition 0^x, because of we don't anything about x, it can be equal zero
							Some(ArInt(1))
						else
							Some(ar0);	
					IntExp(l0,r0):
						if(l0 == 1) 
							Some(ArInt(1))
						else
							Some(ar0);			
					default:
						Some(ar0);
				}
			}	
		});

		it1 = execSimplifier(it0, \op, ar0 -> {
			if(op != "*")
				Some(ar0)
			else
			{
				p = cast(ar0 : ArExp -> ArMult);
				switch(detectOperands(p.l,p.r)) {
					IntInt(l0,r0):
						if(r0 == 0 || l0 == 0)//x*0 or 0*r
							Some(ArInt(0))
						else if(r0 == 1)//x*1 or 1*x
							Some(ArInt(l0))
						else if(l0 == 1)
							Some(ArInt(r0))
						else if(r0 == -1)//x*(-1) or (-1)*x
							Some(ArInt(-l0))
						else if(l0 == -1)
							Some(ArInt(-r0))	
						else if(l0 == r0) // x*x = x^2. it used for foldEqualOperands
							Some(ArPow(ArInt(l0), ArInt(2)))
						else	
							Some(ar0);	
					VarInt(l0,r0):
						if(r0 == 0)
							Some(ArInt(0))
						else if(r0 == 1)
							Some(ArVar(l0))
						else
							Some(ar0);
					ExpInt(l0,r0):
						if(r0 == 0)
							Some(ArInt(0))
						else if(r0 == 1)
							Some(l0)
						else
							Some(ar0);		
					IntVar(l0,r0):
						if(l0 == 0)
							Some(ArInt(0))
						else if(l0 == 1)
							Some(ArVar(r0))
						else
							Some(ar0);	
					IntExp(l0,r0):
						if(l0 == 0)
							Some(ArInt(0))
						else if(l0 == 1)
							Some(r0)
						else
							Some(ar0);						
					VarVar(l0,r0):
						if(r0 == l0)
							Some(ArPow(ArVar(l0), ArInt(2)))
						else	
							Some(ar0);
					ExpExp(l0,r0):
						if(r0 == l0)
							Some(ArPow(l0, ArInt(2)))
						else	
							Some(ar0);		
					default:
						Some(ar0);		
				}
			}	
		});

		it2 = execSimplifier(it1, \op, ar0 -> {
			if(op != "/")
				Some(ar0)
			else
			{
				p = cast(ar0 : ArExp -> ArDiv);
				switch(detectOperands(p.up,p.down)) {
					IntInt(l0,r0):
						if(l0 == 0)// 0/x
							Some(ArInt(0))
						else if(r0 == 0)//divide by zero
							None()
						else if(r0 == 1)// x/1
							Some(ArInt(l0))
						else if(r0 == -1)// x/(-1)
							Some(ArInt(-l0))
						else if(r0 == l0)// x/x
							Some(ArInt(1))
						else if(r0 == -l0)// x/(-x)
							Some(ArInt(-1))
						else 	
							Some(ar0);	
					VarInt(l0,r0):// another conditions similar to the previous conditions
						if(r0 == 0)
							None()
						else if(r0 == 1)
							Some(ArVar(l0))
						else
							Some(ar0);
					ExpInt(l0,r0):
						if(r0 == 0)
							None()
						else if(r0 == 1)
							Some(l0)
						else
							Some(ar0);		
					IntVar(l0,r0):
						if(l0 == 0)
							Some(ArInt(0))
						else
							Some(ar0);
					IntExp(l0,r0):
						if(l0 == 0)
							Some(ArInt(0))
						else
							Some(ar0);		
					VarVar(l0,r0):
						if(l0 == r0)
							Some(ArInt(1))
						else
							Some(ar0);	
					ExpExp(l0,r0):
						if(l0 == r0)
							Some(ArInt(1))
						else
							Some(ar0);		
					default:
						Some(ar0);				
				}
			}	
		});

		it3 = execSimplifier(it2, \op, ar0 -> {
			if(op != "-")
				Some(ar0)
			else
			{
				p = cast(ar0 : ArExp -> ArMin);
				switch(detectOperands(p.l,p.r)) {
					IntInt(l0,r0):
						if(r0 == l0) // x-x
							Some(ArInt(0))
						else if(l0 == 0)// 0-x
							Some(ArInt(-r0))
						else if(r0 == 0)// x-0
							Some(ArInt(l0))
						else if(r0 == -l0) // -x-x = -2x
							Some(ArMult(ArInt(-2), ArInt(r0)))
						else if(l0 == -r0) // x - (-x) = 2x
							Some(ArMult(ArInt(2), ArInt(l0)))
						else		
							Some(ar0);	
					VarInt(l0,r0):// another conditions similar to the previous conditions
						if(r0 == 0)
							Some(ArVar(l0))
						else
							Some(ar0);
					ExpInt(l0,r0):
						if(r0 == 0)
							Some(l0)
						else
							Some(ar0);		
					IntVar(l0,r0):
						if(l0 == 0)
							Some(ArMult(ArInt(-1), ArVar(r0)))
						else
							Some(ar0);
					IntExp(l0,r0):
						if(l0 == 0)
							Some(ArMult(ArInt(-1), r0))
						else
							Some(ar0);		
					VarVar(l0,r0):
						if(l0 == r0)
							Some(ArInt(0))
						else
							Some(ar0);		
					ExpExp(l0,r0):
						if(l0 == r0)
							Some(ArInt(0))
						else
							Some(ar0);		
					default:
						Some(ar0);			
				}
			}	
		});

		it4 = execSimplifier(it3, \op, ar0 -> {
			if(op != "+")
				Some(ar0)
			else
			{
				p = cast(ar0 : ArExp -> ArSum);
				switch(detectOperands(p.l,p.r)) {
					IntInt(l0,r0):
						if(l0 == 0)// 0+x
							Some(ArInt(r0))
						else if(r0 == 0)// x+0
							Some(ArInt(l0))
						else if(r0 == l0) // x+x = 2x
							Some(ArMult(ArInt(2), ArInt(l0)))
						else if(r0 == -l0) // x+(-x) = 0
							Some(ArInt(0))
						else
							Some(ar0);	
					VarInt(l0,r0):// another conditions similar to the previous conditions
						if(r0 == 0)
							Some(ArVar(l0))
						else
							Some(ar0);
					ExpInt(l0,r0):// another conditions similar to the previous conditions
						if(r0 == 0)
							Some(l0)
						else
							Some(ar0);		
					IntVar(l0,r0):
						if(l0 == 0)
							Some(ArVar(r0))
						else
							Some(ar0);
					IntExp(l0,r0):
						if(l0 == 0)
							Some(r0)
						else
							Some(ar0);		
					VarVar(l0,r0):
						if(l0 == r0)
							Some(ArMult(ArInt(2), ArVar(l0)))
						else
							Some(ar0);	
					ExpExp(l0,r0):
						if(l0 == r0)
							Some(ArMult(ArInt(2), l0))
						else
							Some(ar0);			
					default:
						Some(ar0);				
				}
			}	
		});	

		if(isNone(it4))
			None()
		else {
			exp = either(it4, ArInt(0));
			oldExp = either(old, ArInt(0));

			if(exp == oldExp)
				it4
			else
				removeTrivialExp(exp, it4, iteration + 1);
		}		
	}
}

execSimplifier(m: Maybe<ArExp>, condOp: (string, ArExp) -> Maybe<ArExp>) -> Maybe<ArExp> {
	if(isNone(m))
		None()
	else
	{
		arr = extractArgs(either(m,ArInt(0)));

		if(length(arr) == 0)
			m
		else {
			newL = detectAndReplace(arr[0], condOp);
			newR = detectAndReplace(arr[1], condOp);
		
			if(isNone(newL) || isNone(newR))
				None()
			else {
				op = detectType(either(m,ArInt(0)));
				condOp(op, createStruct(op, either(newL, ArInt(0)), either(newR, ArInt(0))))
			}	
		}
	}
}

detectAndReplace(ar:ArExp, condOp) -> Maybe<ArExp> {
	switch(ar) {
		ArInt(val): 
			Some(ar);
		ArVar(var):
			Some(ar);
		default:
			execSimplifier(Some(ar), condOp);
	}
}

extractArgs(ar:ArExp) -> [ArExp] {
	switch(ar) {
		ArPow(l, power):
			[l,power];
		ArDiv(up, down): 
			[up,down];
		ArMin(l, r): 
			[l,r];
		ArSum(l, r): 
			[l,r];
		ArMult(l, r): 
			[l,r];
		default:
			[];
	}	
}

detectType(ar: ArExp) -> string {
	switch (ar) {
		ArPow(l, power):
			"^";
		ArDiv(up, down): 
			"/";
		ArMin(l, r): 
			"-";
		ArSum(l, r): 
			"+";
		ArMult(l, r): 
			"*";
		ArInt(val): 
			"int";
		ArVar(var):
			"variable";	
	}
}

createStruct(op: string, l:ArExp, r:ArExp) -> ArExp {
	if(op == "+")
	{
		ArSum(l,r);
	}else if(op == "-")
	{
		ArMin(l,r);
	}else if(op == "*")
	{
		ArMult(l,r);
	}else if(op == "/")
	{
		ArDiv(l,r);
	}else if(op == "^")
	{
		ArPow(l,r);
	}else 
		l;
}

Args ::= IntInt, IntVar, IntExp, VarInt, VarVar, VarExp, ExpInt, ExpVar, ExpExp;
//----------------------------------
IntInt(l:int, r:int);
IntVar(l:int, r:string);
IntExp(l:int, r:ArExp);

VarInt(l:string, r:int);
VarVar(l:string, r:string); 
VarExp(l:string, r:ArExp);

ExpInt(l:ArExp, r:int);
ExpVar(l:ArExp, r:string);
ExpExp(l:ArExp, r:ArExp);
//----------------------------------

detectOperands(l:ArExp, r:ArExp) -> Args {
	switch (l) {
		ArInt(val):
			switch (r) {
				ArInt(val1):
					IntInt(val, val1);
				ArVar(var1):
					IntVar(val, var1);
				default:
					IntExp(val, r);
			}
		ArVar(var):
			switch (r) {
				ArInt(val1):
					VarInt(var, val1);
				ArVar(var1):
					VarVar(var, var1);
				default:
					VarExp(var, r);
			}
		default:
			switch (r) {
				ArInt(val1):
					ExpInt(l, val1);
				ArVar(var1):
					ExpVar(l, var1);
				default:
					ExpExp(l,r);
		}
	}
}