import syntax_tree;

export {
	simplifyTree(ar:ArExp) -> ArExp;
	extractArgs(ar:ArExp) -> [ArExp];
}

simplifyTree(ar:ArExp) -> ArExp {
	//transform and extract signs like x + (-y) = x-y
	it0 = foldSigns(ar);
	//Find simple expression like a^1, a+0, a*0, a-0 etc
	it1 = removeTrivialExp(it0);
	it2 = foldSigns(it1);
	//Simplify more complex expression like (x-y) + (x+y) = 2x
	it3 = foldExpressions(it2);

	if(ar == it3)
		ar
	else
		simplifyTree(it3);	
} 

foldSigns(ar:ArExp) -> ArExp {
	it = extractSign(ar);

	if(it.second == ar) {
	{
		if(it.first == -1)
			ArMult(ArDouble(-1.0), it.second)
		else
			it.second;	
	}
	}else
	{
		if(it.first == -1)
		{
			if(getD(it.second).first)
				ArDouble(getD(it.second).second * -1.0)
			else
				foldSigns(ArMult(ArDouble(-1.0), it.second));
		}
		else
			foldSigns(it.second);
	}
}

foldExpressions(ar:ArExp) -> ArExp {
	it = execSimplifier(ar, \op, mAr -> {
		args = extractArgs(mAr);
		if(length(args) == 2)
		{
			p0 = foldSigns(args[0]);
			p1 = foldSigns(args[1]);
			op0 = detectType(p0);
			op1 = detectType(p1);
			arg0 = extractArgs(p0);
			arg1 = extractArgs(p1);

			if(op == "+") {
				if(op0 == "+" && op1 == "-") {
					if(arg1[1] == arg0[0])//(x+y)+(z-x) = y+z
						ArSum(arg0[1], arg1[0])
					else if(arg1[1] == arg0[1])//(y+x)+(z-x) = y+z
						ArSum(arg0[0], arg1[0])
					else mAr;	
				}else if(op0 == "-" && op1 == "+") {
					if(arg0[1] == arg1[0]) //(y-x)+(x+z) = y+z
						ArSum(arg0[0], arg1[1])
					else if(arg0[1] == arg1[1]) //(y-x)+(z+x) = y+z
						ArSum(arg0[0], arg1[0])
					else mAr;
				}else if(op0 == "-" && op1 == "-") {
					if(arg0[0] == arg1[1]) //(x-y)+(z-x) = -y+z = z-y
						ArMin(arg1[0], arg0[1])
					else mAr;	
				}else if(isAtom(arg1[0]) || isAtom(arg0[0]))
				{
					if(op0 == "-" && arg0[1] == arg1[0]) arg0[0] // (x-y)+y = x
					else if(op1 == "-" && arg1[1] == arg0[0]) arg1[0] // y+(x-y) = x
					else mAr;	
				}else mAr;
			}else if(op == "-") {
				if(op0 == "+" && op1 == "-") {
					if(arg1[0] == arg0[0]) // (x+y)-(y-z) = x+z
						ArSum(arg0[1], arg1[1])
					else if(arg1[0] == arg0[1]) // (y+x)-(y-z) = x+z
						ArSum(arg0[0], arg1[1])	
					else
						mAr;	
				}else if(op0 == "-" && op1 == "+") {
					if(arg0[0] == arg1[1]) // (y-x)-(z+y) = -1 * (x+z)
						ArMult(ArDouble(-1.0), ArSum(arg0[1], arg1[0]))
					else if(arg0[0] == arg1[0]) // (y-x)-(y+z) = -1 * (x+z)
						ArMult(ArDouble(-1.0), ArSum(arg0[1], arg1[1]))
					else mAr;	
				}else if(op0 == "-" && op1 == "-") {
					if(arg0[1] == arg1[1]) // (x-y)-(z-y) = x-z
						ArMin(arg0[0],arg1[0])
					else mAr;
				}else if(op0 == "+" && op1 == "+") {// (x+y)-(z+y) = x-z
					if(arg0[0] == arg1[1]) 
						ArMin(arg0[1],arg1[0])
					else if(arg0[0] == arg1[0]) 
						ArMin(arg0[1],arg1[1])
					else if(arg0[1] == arg1[1]) 
						ArMin(arg0[0],arg1[0])
					else if(arg0[1] == arg1[0]) 
						ArMin(arg0[0],arg1[1])
					else mAr;
				}else if(isAtom(arg1[0]) || isAtom(arg0[0]))
				{
					if(op0 == "+" && arg0[1] == arg1[0]) arg0[0] // (x+y)-y = x
					else if(op0 == "+" && arg0[0] == arg1[0]) arg0[1]  // (y+x)-y = x
					else if(op0 == "-" && arg0[0] == arg1[0]) ArMult(ArDouble(-1.0), arg0[1]) // (y-x)-y
					else if(op1 == "+" && arg0[0] == arg1[0]) ArMult(ArDouble(-1.0), arg1[1]) // y-(y+x) = -x
					else if(op1 == "+" && arg0[0] == arg1[1]) ArMult(ArDouble(-1.0), arg1[0]) // y-(x+y) = -x
					else if(op1 == "-" && arg0[0] == arg1[0]) arg1[1] // y-(y-x) = x
					else mAr;	
				}else mAr;
			}else mAr;
		}else mAr;
	});

	if(it == ar)
		it
	else
		foldExpressions(it);
} 

removeTrivialExp(ar:ArExp) -> ArExp {
	isZero = \ar0 -> getD(ar0).first && getD(ar0).second == 0.0;
	isOne = \ar0 -> getD(ar0).first && getD(ar0).second == 1.0;
	getVal = \ar0 -> getD(ar0).second;
	it = execSimplifier(ar, \op, mAr -> {
		args = extractArgs(mAr);
		if(length(args) == 2)
		{
			if(getD(args[0]).first && getD(args[1]).first)
				ArDouble(convVals(op, getVal(args[0]), getVal(args[1])))
			else if(op == "^") {
				if(isZero(args[1]) || isOne(args[0]))
					one()
				else if(isOne(args[1]))//x^1
					args[0]
				else if(isZero(args[0]) && getD(args[1]).first && isOne(args[1]))//0^x, there we can set it, because of x != 0, it we can find out from the conditions above
					zero()
				else mAr;
			}else if(op == "*") {
				if(isZero(args[1]) || isZero(args[0]))//x*0 or 0*r
					zero()
				else if(isOne(args[1]))//x*1 or 1*x
					args[0]
				else if(isOne(args[0]))
					args[1]
				else if(args[0] == args[1])
					ArPow(args[0], two())
				else mAr;	
			}else if(op == "/") {
				if(isZero(args[0]))// 0/x
					zero()
				else if(isOne(args[1]))// x/1
					args[0]
				else if(args[0] == args[1])// x/x
					one()
				else mAr;
			}else if(op == "-") {
				if(args[0] == args[1]) // x-x
					zero()
				else if(isZero(args[1]))// x-0
					args[0]
				else mAr;
			}else if(op == "+") {
				if(isZero(args[0]))// 0+x
					args[1]
				else if(isZero(args[1]))// x+0
					args[0]
				else if(args[0] == args[1]) // x+x = 2x
					ArMult(two(), args[0])
				else mAr;	
			}else if(op == "ln") {
				if(isOne(args[0]))// ln(1)=0
					zero()
				else if(getVal(args[0]) == E_CONST)// ln(e)= 1
					one()
				else mAr;	
			}else mAr;
		}else 
			mAr;	
	});	

	if(it == ar)
		it
	else
		removeTrivialExp(it);		
}

execSimplifier(m: ArExp, condOp: (string, ArExp) -> ArExp) -> ArExp {
	arr = extractArgs(m);

	if(length(arr) < 2)
		m
	else 
	{
		newL = detectAndReplace(arr[0], condOp);
		newR = detectAndReplace(arr[1], condOp);

		op = detectType(m);
		condOp(op, createStruct(op, newL, detectAndReplace(arr[1], condOp)));
	}
}

detectAndReplace(ar:ArExp, condOp) -> ArExp {
	switch(ar) {
		ArDouble(val): 
			ar;
		ArVar(var):
			ar;
		default:
			execSimplifier(ar, condOp);
	}
}

extractArgs(ar:ArExp) -> [ArExp] {
	switch(ar) {
		ArPow(l, power):
			[l,power];
		ArDiv(up, down): 
			[up,down];
		ArMin(l, r): 
			[l,r];
		ArSum(l, r): 
			[l,r];
		ArMult(l, r): 
			[l,r];
		ArLn(v):
			[v,zero()];
		default:
			[ar];
	}	
}

isAtom(a) {
	switch(a) {
		ArDouble(val): true;
		ArVar(var): true;
		default: false;
	}
}

isNegInt(a) {
	p = getD(a); 
	p.second < 0.0;
}

extractSign(ar:ArExp) -> Pair<int, ArExp> {
	arr = extractArgs(ar);

	if(length(arr) < 2)
	{
		if(getD(ar).first && getD(ar).second < 0.0)
			Pair(-1, ArDouble(abs(getD(ar).second)))
		else
			Pair(1, ar);
	}else 
	{
		op = detectType(ar);

		newL = extractSign(arr[0]);
		newR = extractSign(arr[1]);
		signMul = \l,r -> if(l*r > 0) 1 else -1;

		if(op == "*" || op == "/") 
			Pair(signMul(newL.first, newR.first), createStruct(op, newL.second, newR.second))
		else if(op == "-") {
			if(newL.first < 0 && newR.first > 0) //-x -y = -1 * (x+y)
				Pair(-1, createStruct("+", newL.second, newR.second))
			else if(newL.first > 0 && newR.first < 0) //x - (-y) = x + y
				Pair(1, createStruct("+", newL.second, newR.second))
			else if(newL.first < 0 && newR.first < 0) //-x - (-y) = -x + y
				Pair(1, createStruct("+", ArMult(ArDouble(-1.0), newL.second), newR.second))
			else
				Pair(1, createStruct(op, newL.second, newR.second));	
		} else if(op == "+") {
			if(newL.first < 0 && newR.first < 0) //-x + (-y) = -1 * (x+y)
				Pair(-1, createStruct("+", newL.second, newR.second))
			else if(newL.first > 0 && newR.first < 0) // x + (-y) = x - y
				Pair(1, createStruct("-", newL.second, newR.second))
			else if(newL.first < 0 && newR.first > 0) // -x + y = y - x
				Pair(1, createStruct("-", newR.second, newL.second))
			else
				Pair(1, createStruct(op, newL.second, newR.second));
		}else
			Pair(1, createStruct(op, newL.second, newR.second));
	}
}

getD(a:ArExp) -> Pair<bool, double> {
	switch (a) {
		ArDouble(val):
			Pair(true, val);
		default:
			Pair(false, 5.0);
	}
}
		
detectType(ar: ArExp) -> string {
	switch (ar) {
		ArPow(l, power): "^";
		ArDiv(up, down): "/";
		ArMin(l, r): "-";
		ArSum(l, r): "+";
		ArMult(l, r): "*";
		ArDouble(val): "int";
		ArVar(var): "variable";	
		ArLn(v): "ln";
	}
}

convVals(op: string, d0: double, d1: double) -> double {
	if(op == "+")
	{
		d0+d1;
	}else if(op == "-")
	{
		d0-d1;
	}else if(op == "*")
	{
		d0*d1;
	}else if(op == "/")
	{
		d0/d1;
	}else if(op == "^")
	{
		dpow(d0, d1);
	}else if(op == "ln")
		log(d0)
	else
		d0;
}

createStruct(op: string, l:ArExp, r:ArExp) -> ArExp {
	if(op == "+")
	{
		ArSum(l,r);
	}else if(op == "-")
	{
		ArMin(l,r);
	}else if(op == "*")
	{
		ArMult(l,r);
	}else if(op == "/")
	{
		ArDiv(l,r);
	}else if(op == "^")
	{
		ArPow(l,r);
	}else if(op == "ln")
		ArLn(l)
	else
		l;	
}

zero() {
	zero()
}

one() {
	one()
}

two() {
	two()
}