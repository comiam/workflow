// HASH COLLISIONS: YES
// timestamp: 1.605095912E12

package main;

import com.area9innovation.flow.*;

@SuppressWarnings("unchecked")
final class Module_gram_engine {
	final main runtime;
	Module_gram_engine(main runtime) {
		this.runtime = runtime;
	}
	Struct_ProgramSequence f_s2pseq(String as) {
		final String l0_gram = "//MAIN SECTION====================================================================================================\nprogram = annotation_begin | code_sequence | code_end | annotation_end;\n\nannotation_begin = ws \"<\" ws formule:f ws \">\" ws semi program:next {Some(ProgramSequence(Annotation(:f),:next))};\ncode_sequence = ws operation:op ws semi program:next {Some(ProgramSequence(:op,:next))};\ncode_end = ws0 '\\n' ws {None()};\nannotation_end   = ws \"<\" ws formule:f ws \">\" ws semi ws0 '\\n' ws {Some(ProgramSequence(Annotation(:f),None()))};\n\noperation = var_define | command;\n\n//VAR DEFENITION SECTOR=======================================================================================\nvar_define = first_state_def | empty_state_def;\n\ntype = int | array;\nint = \"int\" {Int(0)};\narray = '[' ws digit$s ws ']' {Array(s2i($s))};\n\nfirst_state_def = type:t ws var_name$s ws eqv ws expression:exp {VarDefine($s, :t, :exp)};\nempty_state_def = type:t ws var_name$s {VarDefine($s, :t, EmptyType())};\n\n//EXPRESSION SECTOR===============================================================================================\nexpression = const | arr_access | var | bin_op | un_op;\n\nconst = digit$s {Int(s2i($s))};\narr_access = var:v '[' ws expression:ind ws ']' {ArrayAccess(:v, :ind)};\nvar = var_name$s {Variable($s)};\nbin_op = '(' ws expression:f ws bin_op_type$op ws expression:s ws ')' {BinOp($op, :f, :s)};\nun_op = un_op_type$s '(' ws expression:exp ws ')' {UnOp($s, :exp)};\n\n//COMMAND SECTOR==================================================================================================\ncommand = If_op | annotated_While | WhileSimple | sequence | choice | annotated_loop | loop | var_arrredefine | var_redefine | test | print;\n\nop_cond = \"(\" ws expression:ex0 ws test_op$s ws expression:ex1 ws \")\" {Test($s, :ex0, :ex1)};\n\nIf_op = \"if\" ws op_cond:t ws \"then\" ws command:c0 ws \"else\" ws command:c1 {If(:t, :c0, :c1)};\nannotated_While = \"while\" ws op_cond:t ws \"<\" ws formule:ann ws \">\" ws \"do\" ws command:c0 {While(:t, :c0, Some(Annotation(:ann)))};\nWhileSimple     = \"while\" ws op_cond:t ws                              \"do\" ws command:c0 {While(:t, :c0, None())};\nsequence = \"(\" ws command:c0 ws \";\" ws command:c1 ws \")\" {Sequence(:c0, :c1)};\nchoice = \"(\" ws command:c0 ws \"U\" ws command:c1 ws\")\" {Choise(:c0, :c1)};\nannotated_loop = \"*\" ws \"<\" ws formule:ann ws \">\" ws command:c {Loop(:c, Some(Annotation(:ann)))};\nloop           = \"*\" ws                              command:c {Loop(:c, None())};\ntest = \"(\" ws expression:ex0 ws test_op$s ws expression:ex1 ws \")?\" {Test($s, :ex0, :ex1)};\nvar_redefine = var_name$s ws eqv ws expression:exp {VarRedefine($s, :exp)};\nvar_arrredefine = var_name$s'[' ws expression:exp0 ws ']' ws eqv ws expression:exp {VarArrayRedefine($s, :exp0, :exp)};\nprint  = \"print\" ws \"(\" ws expression:e ws \")\" {Print(:e)};\n\n//FORMULE SECTION=================================================================================================\nformule = neg | atom | or | and | impl | allq | exq;\nlogic_expression = lconst | lvar | lbin_op;\n\nlconst = digit$s {LInt(s2i($s))};\nlvar = var_name$s {LVariable($s)};\nlbin_op = '(' ws logic_expression:f ws bin_op_type$op ws logic_expression:s ws ')' {LBinOp($op, :f, :s)};\n\nneg = \"!\" ws formule:a0 {Neg(:a0)};\natom = \"(\" ws logic_expression:ex0 ws test_op$s ws logic_expression:ex1 ws \")\" {Atom($s, :ex0, :ex1)};\nor = \"(\" ws formule:a0 ws \"|\" ws formule:a1 ws \")\" {Or(:a0, :a1)};\nand = \"(\" ws formule:a0 ws \"&\" ws formule:a1 ws \")\" {And(:a0, :a1)};\nimpl = \"(\" ws formule:a0 ws \"->\" ws formule:a1 ws \")\" {Implication(:a0, :a1)};\nallq = \"All\" ws var_name$s ws formule:a1 {AllQuantor($s, :a1)};\nexq = \"Exists\" ws var_name$s ws formule:a1 {ExiQuantor($s, :a1)};\n\n//MISCELLANEOUS===================================================================================================\ntest_op = \"==\" | \"!=\" | \"<=\" | \">=\" | '<' | '>';\nun_op_type = \"--\" | \"++\";\nbin_op_type = '+' | '-' | '*' | '/';\ndigit  = ('0'-'9')+;\nsemi = ';';\neqv = '=';\nvar_name = ('a'-'z')+ ('0'-'9')*;\nws = (' ' | '\\t' | '\\n' | '\\r')*;\nws0 = (' ' | '\\t' | '\\r')*;\n\n";
		return ((Struct_ProgramSequence)runtime.m_maybe.f_either(((Struct)runtime.m_driver.f_parsic(runtime.m_driver.f_compilePegGrammar(l0_gram), as, runtime.m_pegaction.g_defaultPegActions)), (new Struct_ProgramSequence(((Struct)SingletonStructs.str_EmptyOp), ((Struct)SingletonStructs.str_None)))));
	}
}
